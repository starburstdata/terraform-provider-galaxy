// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_data_quality_summary

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DataQualitySummaryDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"catalog_id": schema.StringAttribute{
				Required:            true,
				Description:         "- A catalog\n- This parameter can be looked up using `name` instead of its Id. Use `name=value` instead of an Id to lookup/search using the `value`. `value` must be encoded ([see RFC](https://www.rfc-editor.org/rfc/rfc3986#section-2.2) including `=`)\n",
				MarkdownDescription: "- A catalog\n- This parameter can be looked up using `name` instead of its Id. Use `name=value` instead of an Id to lookup/search using the `value`. `value` must be encoded ([see RFC](https://www.rfc-editor.org/rfc/rfc3986#section-2.2) including `=`)\n",
			},
			"category_counts": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"category": schema.StringAttribute{
							Computed:            true,
							Description:         "Data quality check category",
							MarkdownDescription: "Data quality check category",
						},
						"failed_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Failed evaluations",
							MarkdownDescription: "Failed evaluations",
						},
						"successful_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Successful evaluations",
							MarkdownDescription: "Successful evaluations",
						},
						"total_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Total evaluations",
							MarkdownDescription: "Total evaluations",
						},
					},
					CustomType: CategoryCountsType{
						ObjectType: types.ObjectType{
							AttrTypes: CategoryCountsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Counts grouped by category (read only)",
				MarkdownDescription: "Counts grouped by category (read only)",
			},
			"daily_summaries": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"day": schema.StringAttribute{
							Computed:            true,
							Description:         "Summarization day",
							MarkdownDescription: "Summarization day",
						},
						"failed_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of failed evaluations conducted on the specified day",
							MarkdownDescription: "Number of failed evaluations conducted on the specified day",
						},
						"successful_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of successful evaluations conducted on the specified day",
							MarkdownDescription: "Number of successful evaluations conducted on the specified day",
						},
						"total_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of total evaluations conducted on the specified day",
							MarkdownDescription: "Number of total evaluations conducted on the specified day",
						},
					},
					CustomType: DailySummariesType{
						ObjectType: types.ObjectType{
							AttrTypes: DailySummariesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Summaries for each day (read only)",
				MarkdownDescription: "Summaries for each day (read only)",
			},
			"schema_id": schema.StringAttribute{
				Required:            true,
				Description:         "A schema from a catalog",
				MarkdownDescription: "A schema from a catalog",
			},
			"severity_counts": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"failed_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Failed evaluations",
							MarkdownDescription: "Failed evaluations",
						},
						"severity": schema.StringAttribute{
							Computed:            true,
							Description:         "Data quality check severity",
							MarkdownDescription: "Data quality check severity",
						},
						"successful_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Successful evaluations",
							MarkdownDescription: "Successful evaluations",
						},
						"total_evaluations": schema.Int64Attribute{
							Computed:            true,
							Description:         "Total evaluations",
							MarkdownDescription: "Total evaluations",
						},
					},
					CustomType: SeverityCountsType{
						ObjectType: types.ObjectType{
							AttrTypes: SeverityCountsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Counts grouped by severities (read only)",
				MarkdownDescription: "Counts grouped by severities (read only)",
			},
			"table_summaries": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"evaluated_checks": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of evaluated quality checks",
							MarkdownDescription: "Number of evaluated quality checks",
						},
						"failed_checks": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of failed quality checks",
							MarkdownDescription: "Number of failed quality checks",
						},
						"not_yet_evaluated_checks": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of not yet evaluated quality checks",
							MarkdownDescription: "Number of not yet evaluated quality checks",
						},
						"number_of_checks": schema.Int64Attribute{
							Computed:            true,
							Description:         "Total number of quality checks",
							MarkdownDescription: "Total number of quality checks",
						},
						"successful_checks": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of successful quality checks",
							MarkdownDescription: "Number of successful quality checks",
						},
						"table_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Table ID",
							MarkdownDescription: "Table ID",
						},
					},
					CustomType: TableSummariesType{
						ObjectType: types.ObjectType{
							AttrTypes: TableSummariesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Summaries per table (read only)",
				MarkdownDescription: "Summaries per table (read only)",
			},
		},
	}
}

type DataQualitySummaryModel struct {
	CatalogId      types.String `tfsdk:"catalog_id"`
	CategoryCounts types.List   `tfsdk:"category_counts"`
	DailySummaries types.List   `tfsdk:"daily_summaries"`
	SchemaId       types.String `tfsdk:"schema_id"`
	SeverityCounts types.List   `tfsdk:"severity_counts"`
	TableSummaries types.List   `tfsdk:"table_summaries"`
}

var _ basetypes.ObjectTypable = CategoryCountsType{}

type CategoryCountsType struct {
	basetypes.ObjectType
}

func (t CategoryCountsType) Equal(o attr.Type) bool {
	other, ok := o.(CategoryCountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CategoryCountsType) String() string {
	return "CategoryCountsType"
}

func (t CategoryCountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return nil, diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return nil, diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return nil, diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return nil, diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CategoryCountsValue{
		Category:              categoryVal,
		FailedEvaluations:     failedEvaluationsVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewCategoryCountsValueNull() CategoryCountsValue {
	return CategoryCountsValue{
		state: attr.ValueStateNull,
	}
}

func NewCategoryCountsValueUnknown() CategoryCountsValue {
	return CategoryCountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCategoryCountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CategoryCountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CategoryCountsValue Attribute Value",
				"While creating a CategoryCountsValue value, a missing attribute value was detected. "+
					"A CategoryCountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CategoryCountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CategoryCountsValue Attribute Type",
				"While creating a CategoryCountsValue value, an invalid attribute value was detected. "+
					"A CategoryCountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CategoryCountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CategoryCountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CategoryCountsValue Attribute Value",
				"While creating a CategoryCountsValue value, an extra attribute value was detected. "+
					"A CategoryCountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CategoryCountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCategoryCountsValueUnknown(), diags
	}

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return NewCategoryCountsValueUnknown(), diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return NewCategoryCountsValueUnknown(), diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return NewCategoryCountsValueUnknown(), diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return NewCategoryCountsValueUnknown(), diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return NewCategoryCountsValueUnknown(), diags
	}

	return CategoryCountsValue{
		Category:              categoryVal,
		FailedEvaluations:     failedEvaluationsVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewCategoryCountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CategoryCountsValue {
	object, diags := NewCategoryCountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCategoryCountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CategoryCountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCategoryCountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCategoryCountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCategoryCountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCategoryCountsValueMust(CategoryCountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CategoryCountsType) ValueType(ctx context.Context) attr.Value {
	return CategoryCountsValue{}
}

var _ basetypes.ObjectValuable = CategoryCountsValue{}

type CategoryCountsValue struct {
	Category              basetypes.StringValue `tfsdk:"category"`
	FailedEvaluations     basetypes.Int64Value  `tfsdk:"failed_evaluations"`
	SuccessfulEvaluations basetypes.Int64Value  `tfsdk:"successful_evaluations"`
	TotalEvaluations      basetypes.Int64Value  `tfsdk:"total_evaluations"`
	state                 attr.ValueState
}

func (v CategoryCountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["category"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["failed_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["successful_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Category.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["category"] = val

		val, err = v.FailedEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed_evaluations"] = val

		val, err = v.SuccessfulEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["successful_evaluations"] = val

		val, err = v.TotalEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_evaluations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CategoryCountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CategoryCountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CategoryCountsValue) String() string {
	return "CategoryCountsValue"
}

func (v CategoryCountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"category":               basetypes.StringType{},
		"failed_evaluations":     basetypes.Int64Type{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"category":               v.Category,
			"failed_evaluations":     v.FailedEvaluations,
			"successful_evaluations": v.SuccessfulEvaluations,
			"total_evaluations":      v.TotalEvaluations,
		})

	return objVal, diags
}

func (v CategoryCountsValue) Equal(o attr.Value) bool {
	other, ok := o.(CategoryCountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Category.Equal(other.Category) {
		return false
	}

	if !v.FailedEvaluations.Equal(other.FailedEvaluations) {
		return false
	}

	if !v.SuccessfulEvaluations.Equal(other.SuccessfulEvaluations) {
		return false
	}

	if !v.TotalEvaluations.Equal(other.TotalEvaluations) {
		return false
	}

	return true
}

func (v CategoryCountsValue) Type(ctx context.Context) attr.Type {
	return CategoryCountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CategoryCountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"category":               basetypes.StringType{},
		"failed_evaluations":     basetypes.Int64Type{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DailySummariesType{}

type DailySummariesType struct {
	basetypes.ObjectType
}

func (t DailySummariesType) Equal(o attr.Type) bool {
	other, ok := o.(DailySummariesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DailySummariesType) String() string {
	return "DailySummariesType"
}

func (t DailySummariesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dayAttribute, ok := attributes["day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day is missing from object`)

		return nil, diags
	}

	dayVal, ok := dayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day expected to be basetypes.StringValue, was: %T`, dayAttribute))
	}

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return nil, diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return nil, diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return nil, diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DailySummariesValue{
		Day:                   dayVal,
		FailedEvaluations:     failedEvaluationsVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewDailySummariesValueNull() DailySummariesValue {
	return DailySummariesValue{
		state: attr.ValueStateNull,
	}
}

func NewDailySummariesValueUnknown() DailySummariesValue {
	return DailySummariesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDailySummariesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DailySummariesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DailySummariesValue Attribute Value",
				"While creating a DailySummariesValue value, a missing attribute value was detected. "+
					"A DailySummariesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DailySummariesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DailySummariesValue Attribute Type",
				"While creating a DailySummariesValue value, an invalid attribute value was detected. "+
					"A DailySummariesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DailySummariesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DailySummariesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DailySummariesValue Attribute Value",
				"While creating a DailySummariesValue value, an extra attribute value was detected. "+
					"A DailySummariesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DailySummariesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDailySummariesValueUnknown(), diags
	}

	dayAttribute, ok := attributes["day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day is missing from object`)

		return NewDailySummariesValueUnknown(), diags
	}

	dayVal, ok := dayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day expected to be basetypes.StringValue, was: %T`, dayAttribute))
	}

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return NewDailySummariesValueUnknown(), diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return NewDailySummariesValueUnknown(), diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return NewDailySummariesValueUnknown(), diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return NewDailySummariesValueUnknown(), diags
	}

	return DailySummariesValue{
		Day:                   dayVal,
		FailedEvaluations:     failedEvaluationsVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewDailySummariesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DailySummariesValue {
	object, diags := NewDailySummariesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDailySummariesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DailySummariesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDailySummariesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDailySummariesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDailySummariesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDailySummariesValueMust(DailySummariesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DailySummariesType) ValueType(ctx context.Context) attr.Value {
	return DailySummariesValue{}
}

var _ basetypes.ObjectValuable = DailySummariesValue{}

type DailySummariesValue struct {
	Day                   basetypes.StringValue `tfsdk:"day"`
	FailedEvaluations     basetypes.Int64Value  `tfsdk:"failed_evaluations"`
	SuccessfulEvaluations basetypes.Int64Value  `tfsdk:"successful_evaluations"`
	TotalEvaluations      basetypes.Int64Value  `tfsdk:"total_evaluations"`
	state                 attr.ValueState
}

func (v DailySummariesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["day"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["failed_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["successful_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Day.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["day"] = val

		val, err = v.FailedEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed_evaluations"] = val

		val, err = v.SuccessfulEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["successful_evaluations"] = val

		val, err = v.TotalEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_evaluations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DailySummariesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DailySummariesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DailySummariesValue) String() string {
	return "DailySummariesValue"
}

func (v DailySummariesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"day":                    basetypes.StringType{},
		"failed_evaluations":     basetypes.Int64Type{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"day":                    v.Day,
			"failed_evaluations":     v.FailedEvaluations,
			"successful_evaluations": v.SuccessfulEvaluations,
			"total_evaluations":      v.TotalEvaluations,
		})

	return objVal, diags
}

func (v DailySummariesValue) Equal(o attr.Value) bool {
	other, ok := o.(DailySummariesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Day.Equal(other.Day) {
		return false
	}

	if !v.FailedEvaluations.Equal(other.FailedEvaluations) {
		return false
	}

	if !v.SuccessfulEvaluations.Equal(other.SuccessfulEvaluations) {
		return false
	}

	if !v.TotalEvaluations.Equal(other.TotalEvaluations) {
		return false
	}

	return true
}

func (v DailySummariesValue) Type(ctx context.Context) attr.Type {
	return DailySummariesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DailySummariesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"day":                    basetypes.StringType{},
		"failed_evaluations":     basetypes.Int64Type{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SeverityCountsType{}

type SeverityCountsType struct {
	basetypes.ObjectType
}

func (t SeverityCountsType) Equal(o attr.Type) bool {
	other, ok := o.(SeverityCountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SeverityCountsType) String() string {
	return "SeverityCountsType"
}

func (t SeverityCountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return nil, diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return nil, diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return nil, diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SeverityCountsValue{
		FailedEvaluations:     failedEvaluationsVal,
		Severity:              severityVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSeverityCountsValueNull() SeverityCountsValue {
	return SeverityCountsValue{
		state: attr.ValueStateNull,
	}
}

func NewSeverityCountsValueUnknown() SeverityCountsValue {
	return SeverityCountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSeverityCountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SeverityCountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SeverityCountsValue Attribute Value",
				"While creating a SeverityCountsValue value, a missing attribute value was detected. "+
					"A SeverityCountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SeverityCountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SeverityCountsValue Attribute Type",
				"While creating a SeverityCountsValue value, an invalid attribute value was detected. "+
					"A SeverityCountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SeverityCountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SeverityCountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SeverityCountsValue Attribute Value",
				"While creating a SeverityCountsValue value, an extra attribute value was detected. "+
					"A SeverityCountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SeverityCountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSeverityCountsValueUnknown(), diags
	}

	failedEvaluationsAttribute, ok := attributes["failed_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_evaluations is missing from object`)

		return NewSeverityCountsValueUnknown(), diags
	}

	failedEvaluationsVal, ok := failedEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_evaluations expected to be basetypes.Int64Value, was: %T`, failedEvaluationsAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewSeverityCountsValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	successfulEvaluationsAttribute, ok := attributes["successful_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_evaluations is missing from object`)

		return NewSeverityCountsValueUnknown(), diags
	}

	successfulEvaluationsVal, ok := successfulEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_evaluations expected to be basetypes.Int64Value, was: %T`, successfulEvaluationsAttribute))
	}

	totalEvaluationsAttribute, ok := attributes["total_evaluations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_evaluations is missing from object`)

		return NewSeverityCountsValueUnknown(), diags
	}

	totalEvaluationsVal, ok := totalEvaluationsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_evaluations expected to be basetypes.Int64Value, was: %T`, totalEvaluationsAttribute))
	}

	if diags.HasError() {
		return NewSeverityCountsValueUnknown(), diags
	}

	return SeverityCountsValue{
		FailedEvaluations:     failedEvaluationsVal,
		Severity:              severityVal,
		SuccessfulEvaluations: successfulEvaluationsVal,
		TotalEvaluations:      totalEvaluationsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSeverityCountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SeverityCountsValue {
	object, diags := NewSeverityCountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSeverityCountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SeverityCountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSeverityCountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSeverityCountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSeverityCountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSeverityCountsValueMust(SeverityCountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SeverityCountsType) ValueType(ctx context.Context) attr.Value {
	return SeverityCountsValue{}
}

var _ basetypes.ObjectValuable = SeverityCountsValue{}

type SeverityCountsValue struct {
	FailedEvaluations     basetypes.Int64Value  `tfsdk:"failed_evaluations"`
	Severity              basetypes.StringValue `tfsdk:"severity"`
	SuccessfulEvaluations basetypes.Int64Value  `tfsdk:"successful_evaluations"`
	TotalEvaluations      basetypes.Int64Value  `tfsdk:"total_evaluations"`
	state                 attr.ValueState
}

func (v SeverityCountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["failed_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["successful_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_evaluations"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FailedEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed_evaluations"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		val, err = v.SuccessfulEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["successful_evaluations"] = val

		val, err = v.TotalEvaluations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_evaluations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SeverityCountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SeverityCountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SeverityCountsValue) String() string {
	return "SeverityCountsValue"
}

func (v SeverityCountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"failed_evaluations":     basetypes.Int64Type{},
		"severity":               basetypes.StringType{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"failed_evaluations":     v.FailedEvaluations,
			"severity":               v.Severity,
			"successful_evaluations": v.SuccessfulEvaluations,
			"total_evaluations":      v.TotalEvaluations,
		})

	return objVal, diags
}

func (v SeverityCountsValue) Equal(o attr.Value) bool {
	other, ok := o.(SeverityCountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FailedEvaluations.Equal(other.FailedEvaluations) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	if !v.SuccessfulEvaluations.Equal(other.SuccessfulEvaluations) {
		return false
	}

	if !v.TotalEvaluations.Equal(other.TotalEvaluations) {
		return false
	}

	return true
}

func (v SeverityCountsValue) Type(ctx context.Context) attr.Type {
	return SeverityCountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SeverityCountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"failed_evaluations":     basetypes.Int64Type{},
		"severity":               basetypes.StringType{},
		"successful_evaluations": basetypes.Int64Type{},
		"total_evaluations":      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TableSummariesType{}

type TableSummariesType struct {
	basetypes.ObjectType
}

func (t TableSummariesType) Equal(o attr.Type) bool {
	other, ok := o.(TableSummariesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TableSummariesType) String() string {
	return "TableSummariesType"
}

func (t TableSummariesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evaluatedChecksAttribute, ok := attributes["evaluated_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evaluated_checks is missing from object`)

		return nil, diags
	}

	evaluatedChecksVal, ok := evaluatedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evaluated_checks expected to be basetypes.Int64Value, was: %T`, evaluatedChecksAttribute))
	}

	failedChecksAttribute, ok := attributes["failed_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_checks is missing from object`)

		return nil, diags
	}

	failedChecksVal, ok := failedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_checks expected to be basetypes.Int64Value, was: %T`, failedChecksAttribute))
	}

	notYetEvaluatedChecksAttribute, ok := attributes["not_yet_evaluated_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_yet_evaluated_checks is missing from object`)

		return nil, diags
	}

	notYetEvaluatedChecksVal, ok := notYetEvaluatedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_yet_evaluated_checks expected to be basetypes.Int64Value, was: %T`, notYetEvaluatedChecksAttribute))
	}

	numberOfChecksAttribute, ok := attributes["number_of_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_of_checks is missing from object`)

		return nil, diags
	}

	numberOfChecksVal, ok := numberOfChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_of_checks expected to be basetypes.Int64Value, was: %T`, numberOfChecksAttribute))
	}

	successfulChecksAttribute, ok := attributes["successful_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_checks is missing from object`)

		return nil, diags
	}

	successfulChecksVal, ok := successfulChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_checks expected to be basetypes.Int64Value, was: %T`, successfulChecksAttribute))
	}

	tableIdAttribute, ok := attributes["table_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_id is missing from object`)

		return nil, diags
	}

	tableIdVal, ok := tableIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_id expected to be basetypes.StringValue, was: %T`, tableIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TableSummariesValue{
		EvaluatedChecks:       evaluatedChecksVal,
		FailedChecks:          failedChecksVal,
		NotYetEvaluatedChecks: notYetEvaluatedChecksVal,
		NumberOfChecks:        numberOfChecksVal,
		SuccessfulChecks:      successfulChecksVal,
		TableId:               tableIdVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTableSummariesValueNull() TableSummariesValue {
	return TableSummariesValue{
		state: attr.ValueStateNull,
	}
}

func NewTableSummariesValueUnknown() TableSummariesValue {
	return TableSummariesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTableSummariesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TableSummariesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TableSummariesValue Attribute Value",
				"While creating a TableSummariesValue value, a missing attribute value was detected. "+
					"A TableSummariesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TableSummariesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TableSummariesValue Attribute Type",
				"While creating a TableSummariesValue value, an invalid attribute value was detected. "+
					"A TableSummariesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TableSummariesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TableSummariesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TableSummariesValue Attribute Value",
				"While creating a TableSummariesValue value, an extra attribute value was detected. "+
					"A TableSummariesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TableSummariesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTableSummariesValueUnknown(), diags
	}

	evaluatedChecksAttribute, ok := attributes["evaluated_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evaluated_checks is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	evaluatedChecksVal, ok := evaluatedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evaluated_checks expected to be basetypes.Int64Value, was: %T`, evaluatedChecksAttribute))
	}

	failedChecksAttribute, ok := attributes["failed_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_checks is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	failedChecksVal, ok := failedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_checks expected to be basetypes.Int64Value, was: %T`, failedChecksAttribute))
	}

	notYetEvaluatedChecksAttribute, ok := attributes["not_yet_evaluated_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_yet_evaluated_checks is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	notYetEvaluatedChecksVal, ok := notYetEvaluatedChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_yet_evaluated_checks expected to be basetypes.Int64Value, was: %T`, notYetEvaluatedChecksAttribute))
	}

	numberOfChecksAttribute, ok := attributes["number_of_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_of_checks is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	numberOfChecksVal, ok := numberOfChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_of_checks expected to be basetypes.Int64Value, was: %T`, numberOfChecksAttribute))
	}

	successfulChecksAttribute, ok := attributes["successful_checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`successful_checks is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	successfulChecksVal, ok := successfulChecksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`successful_checks expected to be basetypes.Int64Value, was: %T`, successfulChecksAttribute))
	}

	tableIdAttribute, ok := attributes["table_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_id is missing from object`)

		return NewTableSummariesValueUnknown(), diags
	}

	tableIdVal, ok := tableIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_id expected to be basetypes.StringValue, was: %T`, tableIdAttribute))
	}

	if diags.HasError() {
		return NewTableSummariesValueUnknown(), diags
	}

	return TableSummariesValue{
		EvaluatedChecks:       evaluatedChecksVal,
		FailedChecks:          failedChecksVal,
		NotYetEvaluatedChecks: notYetEvaluatedChecksVal,
		NumberOfChecks:        numberOfChecksVal,
		SuccessfulChecks:      successfulChecksVal,
		TableId:               tableIdVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTableSummariesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TableSummariesValue {
	object, diags := NewTableSummariesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTableSummariesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TableSummariesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTableSummariesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTableSummariesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTableSummariesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTableSummariesValueMust(TableSummariesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TableSummariesType) ValueType(ctx context.Context) attr.Value {
	return TableSummariesValue{}
}

var _ basetypes.ObjectValuable = TableSummariesValue{}

type TableSummariesValue struct {
	EvaluatedChecks       basetypes.Int64Value  `tfsdk:"evaluated_checks"`
	FailedChecks          basetypes.Int64Value  `tfsdk:"failed_checks"`
	NotYetEvaluatedChecks basetypes.Int64Value  `tfsdk:"not_yet_evaluated_checks"`
	NumberOfChecks        basetypes.Int64Value  `tfsdk:"number_of_checks"`
	SuccessfulChecks      basetypes.Int64Value  `tfsdk:"successful_checks"`
	TableId               basetypes.StringValue `tfsdk:"table_id"`
	state                 attr.ValueState
}

func (v TableSummariesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["evaluated_checks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["failed_checks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["not_yet_evaluated_checks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_of_checks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["successful_checks"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["table_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.EvaluatedChecks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evaluated_checks"] = val

		val, err = v.FailedChecks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed_checks"] = val

		val, err = v.NotYetEvaluatedChecks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_yet_evaluated_checks"] = val

		val, err = v.NumberOfChecks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_of_checks"] = val

		val, err = v.SuccessfulChecks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["successful_checks"] = val

		val, err = v.TableId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TableSummariesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TableSummariesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TableSummariesValue) String() string {
	return "TableSummariesValue"
}

func (v TableSummariesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"evaluated_checks":         basetypes.Int64Type{},
		"failed_checks":            basetypes.Int64Type{},
		"not_yet_evaluated_checks": basetypes.Int64Type{},
		"number_of_checks":         basetypes.Int64Type{},
		"successful_checks":        basetypes.Int64Type{},
		"table_id":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"evaluated_checks":         v.EvaluatedChecks,
			"failed_checks":            v.FailedChecks,
			"not_yet_evaluated_checks": v.NotYetEvaluatedChecks,
			"number_of_checks":         v.NumberOfChecks,
			"successful_checks":        v.SuccessfulChecks,
			"table_id":                 v.TableId,
		})

	return objVal, diags
}

func (v TableSummariesValue) Equal(o attr.Value) bool {
	other, ok := o.(TableSummariesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvaluatedChecks.Equal(other.EvaluatedChecks) {
		return false
	}

	if !v.FailedChecks.Equal(other.FailedChecks) {
		return false
	}

	if !v.NotYetEvaluatedChecks.Equal(other.NotYetEvaluatedChecks) {
		return false
	}

	if !v.NumberOfChecks.Equal(other.NumberOfChecks) {
		return false
	}

	if !v.SuccessfulChecks.Equal(other.SuccessfulChecks) {
		return false
	}

	if !v.TableId.Equal(other.TableId) {
		return false
	}

	return true
}

func (v TableSummariesValue) Type(ctx context.Context) attr.Type {
	return TableSummariesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TableSummariesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"evaluated_checks":         basetypes.Int64Type{},
		"failed_checks":            basetypes.Int64Type{},
		"not_yet_evaluated_checks": basetypes.Int64Type{},
		"number_of_checks":         basetypes.Int64Type{},
		"successful_checks":        basetypes.Int64Type{},
		"table_id":                 basetypes.StringType{},
	}
}
